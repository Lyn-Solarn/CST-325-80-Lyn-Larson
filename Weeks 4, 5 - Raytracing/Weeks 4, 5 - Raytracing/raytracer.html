<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Raytracer</title>
</head>
<body>
<canvas id='my-canvas'></canvas>

<script src='math/vector3.js'></script>
<script src='math/ray.js'></script>
<script src='math/sphere.js'></script>
<script src='math/plane.js'></script>
<script>

// Canvas setup, don't need to do anything in this section ************************
// Get a reference to the javascript object associated with the canvas
const canvas = document.getElementById('my-canvas');

// The canvas dimension we will set
const pixelsAcross = 256;  // pixels across
const pixelsDown = 256; // pixels down

// How much we scale a single pixel.  This has no effect on our computations. Change it to your liking.
const pixelScale = 3;

// Set up the size of our canvas in pixels
canvas.width = pixelsAcross;
canvas.height = pixelsDown;
canvas.style.cssText = 'width:' + (pixelsAcross * pixelScale) + 'px;height:' + (pixelsDown * pixelScale) + 'px';

// Get the context from the canvas (in this case we just want 2d)
const canvasContext = canvas.getContext('2d');

// Get an array representing all of the pixels
// Arranged left to right, top to bottom
const imageData = canvasContext.getImageData(0, 0, pixelsAcross, pixelsDown);
// end canvas setup section *****************************************************


// Raytracer scene data setup ***************************************************

// if this changes, your code should still work
const fov = 45; 
let fovRadians = fov * (Math.PI/180); // todo -> convert degrees to radians
let pixelWidth = 2/pixelsAcross; // todo -> what's the size of a pixel from left to right?
let pixelHalfWidth = pixelWidth/2; // todo -> half of the pixel width

// How far away (scalar) the eye is from the image plane (see project guide for more info)
let eyeDistance = 1 / Math.tan(fovRadians / 2); // todo -> use the fov to calculate this distance
// -----------
// |         /
// |        /
// |       /
// | 45/2 /      <---- half angle
// |     /
// |    /
// |   /
// |  /
// | /

let eyeCoordinate = new Vector3(0, 0, eyeDistance); // todo -> set this after eyeDistance is calculated

// Define the scene objects here ------------------

// These are 3d definitions that match all of the math we did in class
// They also provide a "raycast" function that you can pass a ray to
// in order to find intersection between the ray and the object

let sphere = new Sphere(new Vector3(0, 0, 0), 0.25); // todo = new Sphere(..., ...);
let plane = new Plane(new Vector3(0, 1, 0,), new Vector3(0, -0.25, 0)); // todo = new Plane(..., ...);
var leftWall = new Plane(new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(1, 0, 0));   // validPoint => (-1, 0, 0)
var rightWall = new Plane(new Vector3(-1, 0, 0), new Vector3(1, 0, 0), new Vector3(0, 1, 0)); // validPoint => (1, 0, 0)
var ceiling = new Plane(new Vector3(0, -1, 0), new Vector3(0, 1, 0), new Vector3(1, 1, 1));   // validPoint => (0, 1, 0)
var backWall = new Plane(new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(1, 1, 1));  // validPoint => (0, 0, -1)

var scene = [sphere, ceiling, plane, leftWall, rightWall, backWall];

// end of raytracer setup ******************************************************


// -----------------------------------------------------------------------------
function generateRayForPixel(xPixelIndex, yPixelIndex) {
	const pixelX = -1 + pixelHalfWidth + pixelWidth * xPixelIndex;
	const pixelY = 1 - pixelHalfWidth - pixelWidth * yPixelIndex;
	const pixelCoordinate = new Vector3(pixelX, pixelY, 0);

	//let direction = Vector3.fromTo(eyeCoordinate, pixelCoordinate);// = vector from the eye to the pixel

  let direction = Vector3.fromTo(eyeCoordinate, pixelCoordinate).normalize();
	// Creates a ray from the eye toward the pixelCoordinate
	let pixelRay = new Ray(eyeCoordinate, direction); // = new Ray(...);
	return pixelRay;

  
  return new Ray(eyeCoordinate, direction);
}

// -----------------------------------------------------------------------------
function setPixelColor(xPixelIndex, yPixelIndex, color /*[0,1]*/) {
	const index = (yPixelIndex * pixelsAcross + xPixelIndex) * 4; // 4 bytes per pixel
	imageData.data[index + 0] = color.x * 255; // red channel
	imageData.data[index + 1] = color.y * 255; // green channel
	imageData.data[index + 2] = color.z * 255; // blue channel
	imageData.data[index + 3] = 255;
}

let lightPos = new Vector3(0.5, 0, 0);

function updateAndRender(timeElapsed) {
  var seconds = timeElapsed * 0.001; // convert milliseconds to seconds
  lightPos.x = Math.cos(seconds) * 0.5; // radius of 0.5
  lightPos.z = Math.sin(seconds) * 0.5; // radius of 0.5

   // Go through every pixel
   // NOTE! You should only call setPixelColor once per pixel.  Otherwise, the
   // last time you call it will be the color and overwrite previous calls.

  for (let y = 0; y < pixelsDown; y++) {
    for (let x = 0; x < pixelsAcross; x++) {

      const ray = generateRayForPixel(x, y);

      const sphereHit = sphere.raycast(ray);
      const planeHit  = plane.raycast(ray);
      const leftWallHit = leftWall.raycast(ray);
      const rightWallHit = rightWall.raycast(ray);
      const ceilingHit = ceiling.raycast(ray);
      const backWallHit = backWall.raycast(ray);

      // Find closest hit in the whole scene

      let closestHit = null;
      let closestObj = null;
      let closestDist = Infinity;

      for (const obj of scene) {
        const h = obj.raycast(ray);
        if (h.hit && h.distance < closestDist) {
          closestDist = h.distance;
          closestHit = h;
          closestObj = obj;
        }
      }


      let color = new Vector3(0.1, 0.1, 0.1); // default

      // todo -> use the raycast results to determine the final color of the pixel
      let finalColor = new Vector3(0.05, 0.05, 0.08);

      if (closestHit && closestObj) {
        // 1) get base color from sphere/plane directly when hit
        let baseColor = new Vector3(0.8, 0.8, 0.8); // fallback
        if (closestObj === sphere && sphere.color instanceof Vector3) {
          baseColor = sphere.color.clone();
        } else if (closestObj === plane && plane.color instanceof Vector3) {
          baseColor = plane.color.clone();
        } else {
        // per-wall or other defaults (adjust as you like)
          if (closestObj === leftWall)  baseColor = leftWall.color.clone();
          if (closestObj === rightWall) baseColor = rightWall.color.clone();
          if (closestObj === ceiling)   baseColor = ceiling.color.clone();
          if (closestObj === backWall)  baseColor = backWall.color.clone();
        }

        // 2) lighting params (tweak to taste)
        const ambientStrength = 0.30;   // increase to brighten shadows
        const lightIntensity  = 1.6;    // brightness of light
        const specularStrength = 0.5;
        const shininess = 20;
        const exposure = 0.5;
        const gamma = 2.0;

        // 3) geometry
        const P = closestHit.point.clone();
        const N = closestHit.normal.clone().normalize();

        // use your existing lightPos if present, otherwise (1,0,0)
        const lp = (typeof lightPos !== "undefined") ? lightPos.clone() : new Vector3(1, 0, 0);
        const toLight = Vector3.fromTo(P, lp);
        const lightDist = toLight.length();
        const L = toLight.clone().normalize();

        // 4) shadow test against all scene objects
        const shadowOrigin = P.clone().add(N.clone().multiplyScalar(1e-4)); // avoid self hit
        const shadowRay = new Ray(shadowOrigin, L);
        let inShadow = false;
        for (const obj of scene) {
          const sh = obj.raycast(shadowRay);
          if (sh.hit && sh.distance > 1e-5 && sh.distance < lightDist - 1e-5) { inShadow = true; break; }
        }

        // 5) diffuse & specular
        let diffuse = Math.max(0, N.dot(L)) * lightIntensity;
        if (inShadow) diffuse *= 0.15; // keep small diffuse when shadowed

        const eyePos = (typeof eye !== "undefined") ? eye.clone() : ((typeof camera !== "undefined") ? camera.clone() : new Vector3(0,0,0));
        const V = Vector3.fromTo(P, eyePos).normalize();
        const negL = L.clone().negate();
        const R = negL.clone().subtract(N.clone().multiplyScalar(2 * negL.dot(N))).normalize();
        let spec = Math.pow(Math.max(0, R.dot(V)), shininess) * specularStrength;
        if (inShadow) spec *= 0.2;

        // 6) combine components
        const ambient = baseColor.clone().multiplyScalar(ambientStrength);
        const diffuseColor = baseColor.clone().multiplyScalar(diffuse);
        const specColor = new Vector3(1,1,1).multiplyScalar(spec);

        finalColor = ambient.add(diffuseColor).add(specColor);

        // 7) exposure, clamp, gamma
        finalColor = finalColor.multiplyScalar(exposure);
        finalColor.x = Math.min(1, Math.max(0, finalColor.x));
        finalColor.y = Math.min(1, Math.max(0, finalColor.y));
        finalColor.z = Math.min(1, Math.max(0, finalColor.z));
        finalColor.x = Math.pow(finalColor.x, 1/gamma);
        finalColor.y = Math.pow(finalColor.y, 1/gamma);
        finalColor.z = Math.pow(finalColor.z, 1/gamma);
      }else {
        // background color (adjust as you like)
        finalColor = new Vector3(0.05, 0.05, 0.08);
      }

      // final: send a Vector3 color (0..1) to setPixelColor
      setPixelColor(x, y, finalColor);


    }
  }

  canvasContext.putImageData(imageData, 0, 0);
  requestAnimationFrame(updateAndRender);
}



// We are ready to render, let the browser know
requestAnimationFrame(updateAndRender);

</script>
<script src="raytracer-tests.js"></script>
</body>
</html>
